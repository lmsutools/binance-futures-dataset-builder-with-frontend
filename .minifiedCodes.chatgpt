<"file: tsconfig.json">{"compilerOptions": {/* Visit https://aka.ms/tsconfig to read more about this file *//* Projects */// "incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */// "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */// "tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */// "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */// "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */// "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. *//* Language and Environment */"target": "es2022",                                  /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */// "lib": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */// "jsx": "preserve",                                /* Specify what JSX code is generated. */"experimentalDecorators": true,                     /* Enable experimental support for legacy experimental decorators. */// "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */// "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */// "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */// "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */// "reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */// "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */// "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */// "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. *//* Modules */"module": "commonjs",                                /* Specify what module code is generated. */// "rootDir": "./",                                  /* Specify the root folder within your source files. */// "moduleResolution": "node10",                     /* Specify how TypeScript looks up a file from a given module specifier. */// "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */// "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */// "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */// "typeRoots": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */// "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */// "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */// "moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */// "allowImportingTsExtensions": true,               /* Allow imports to include TypeScript file extensions. Requires '--moduleResolution bundler' and either '--noEmit' or '--emitDeclarationOnly' to be set. */// "resolvePackageJsonExports": true,                /* Use the package.json 'exports' field when resolving package imports. */// "resolvePackageJsonImports": true,                /* Use the package.json 'imports' field when resolving imports. */// "customConditions": [],                           /* Conditions to set in addition to the resolver-specific defaults when resolving imports. */// "resolveJsonModule": true,                        /* Enable importing .json files. */// "allowArbitraryExtensions": true,                 /* Enable importing files with any extension, provided a declaration file is present. */// "noResolve": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. *//* JavaScript Support */// "allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */// "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */// "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. *//* Emit */// "declaration": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */// "declarationMap": true,                           /* Create sourcemaps for d.ts files. */// "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */// "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */// "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */// "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */"outDir": "./dist",                                   /* Specify an output folder for all emitted files. */// "removeComments": true,                           /* Disable emitting comments. */// "noEmit": true,                                   /* Disable emitting files from a compilation. */// "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */// "importsNotUsedAsValues": "remove",               /* Specify emit/checking behavior for imports that are only used for types. */// "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */// "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */// "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */// "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */// "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */// "newLine": "crlf",                                /* Set the newline character for emitting files. */// "stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */// "noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */// "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */// "preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */// "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */// "preserveValueImports": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. *//* Interop Constraints */// "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */// "verbatimModuleSyntax": true,                     /* Do not transform or elide any imports or exports not marked as type-only, ensuring they are written in the output file's format based on the 'module' setting. */// "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */"esModuleInterop": true,                             /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */// "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */"forceConsistentCasingInFileNames": true,            /* Ensure that casing is correct in imports. *//* Type Checking */"strict": true,                                      /* Enable all strict type-checking options. */// "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied 'any' type. */// "strictNullChecks": true,                         /* When type checking, take into account 'null' and 'undefined'. */// "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */// "strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */// "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */// "noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */// "useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */// "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */// "noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */// "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */// "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */// "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */// "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */// "noUncheckedIndexedAccess": true,                 /* Add 'undefined' to a type when accessed using an index. */// "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */// "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */// "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */// "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. *//* Completeness */// "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */"skipLibCheck": true                                 /* Skip type checking all .d.ts files. */}}</"file: tsconfig.json">

<"file: src\external-request\index.ts">export * from "./interfaces";export * from "./external-request.service";</"file: src\external-request\index.ts">

<"file: src\external-request\interfaces.ts">import * as http from "http";// Serviceexport interface IExternalRequestService {request(options: IExternalRequestOptions,params?: any,protocol_name?: IExternalRequestProtocolName): Promise<IExternalRequestResponse>}// Optionsexport type IExternalRequestOptions = http.RequestOptions;// Responseexport interface IExternalRequestResponse {status_code: number|undefined,headers: http.IncomingHttpHeaders,data?: any};// Protocolexport type IExternalRequestProtocolName = "http"|"https";</"file: src\external-request\interfaces.ts">

<"file: src\index.ts">import { sync_datasets } from "./dataset-builder";// Print the script titleconsole.log("BINANCE FUTURES DATASET BUILDER");console.log(" ");// Start the syncing processsync_datasets().then(_ => {console.log("\n\nThe datasets has been synced successfully");process.exit(0);} ).catch(e => {console.error(e);process.exit(1);});</"file: src\index.ts">

<"file: src\dataset-builder\taker-buy-sell-volume.service.ts">import { IRawTakerBuySellVolumeRecord } from "../binance";import { DatasetBuilder } from "./dataset-builder";import { ITakerBuySellVolumeRecord, ITakerBuySellVolumeService } from "./interfaces";export class TakerBuySellVolumeService extends DatasetBuilder implements ITakerBuySellVolumeService {constructor() {super("./output/taker_buy_sell_volume.csv",30);}/*** Retrieves the next dataset items based on the given starting point.* @param start_at* @returns Promise<ITakerBuySellVolumeRecord[]>*/protected async get_next_ds_items(start_at: number): Promise<ITakerBuySellVolumeRecord[]> {// Retrieve the records from Binance's APIconst records: IRawTakerBuySellVolumeRecord[] = await this._binance.get_taker_buy_sell_volume_history(start_at);// Finally, format the items and return themreturn records.map((r) => { return <ITakerBuySellVolumeRecord>{timestamp: r.timestamp,buy_vol: this.format_number(r.buyVol, 4),sell_vol: this.format_number(r.sellVol, 4),buy_sell_ratio: this.format_number(r.buySellRatio, 4)} });}}</"file: src\dataset-builder\taker-buy-sell-volume.service.ts">

<"file: src\external-request\external-request.service.ts">import * as http from "http";import * as https from "https";import {IExternalRequestService,IExternalRequestProtocolName,IExternalRequestResponse,IExternalRequestOptions} from "./interfaces";export class ExternalRequestService implements IExternalRequestService {/*** The maximum amount of time a request can go for. An error is thrown* if the request takes longer than this value. A custom timeout can be* specified in the options object.*/private readonly request_timeout: number = 180 * 1000; // 3 minutesconstructor() {}/*** Performs an HTTP/HTTPS based on provided parameters. The final response must be reviewed* as it can include errors thrown by the request recipient.* @param options* @param params* @param protocol_name* @returns Promise<IExternalRequestResponse>*/public request(options: IExternalRequestOptions,params?: any,protocol_name?: IExternalRequestProtocolName): Promise<IExternalRequestResponse> {return new Promise((resolve, reject) => {// Init the protocol to be usedconst protocol: any = protocol_name == "http" ? http: https;// Check if a request timeout has been setif (typeof options.timeout != "number") options.timeout = this.request_timeout;// Perform the requestlet request: http.ClientRequest = protocol.request(options, (response: http.IncomingMessage) => {// Init response datalet data: string = "";let final_response: IExternalRequestResponse = {status_code: response.statusCode,headers: response.headers};// On data changesresponse.on("data",  (chunk)=> {data += chunk;});// Once it endsresponse.on("end",  () => {// Verify if data was includedif (!data) {resolve(final_response);} else {try {final_response.data = JSON.parse(data);resolve(final_response);}catch(err) {final_response.data = data;resolve(final_response);}}});// If there is an errorresponse.on("error",(err) => { reject(err) })});// Append params if applicableconst final_params: string|undefined = this.get_final_params(params);if (final_params != undefined) request.write(final_params);// End requestrequest.end();});}/*** Given the params, it will attempt to convert it into a valid string based on* the format* @param params* @returns string|undefined*/private get_final_params(params?: any): string|undefined {// None providedif (!params) { return undefined }// String Paramelse if (typeof params == "string") { return params }// Object Paramelse if (typeof params == "object") { return JSON.stringify(params) }// Unknown formatelse { return String(params) }}}</"file: src\external-request\external-request.service.ts">

<"file: src\dataset-builder\long-short-ratio.service.ts">import { IRawLongShortRatioRecord } from "../binance";import { DatasetBuilder } from "./dataset-builder";import { ILongShortRatioService, ILongShortRatioRecord } from "./interfaces";export class LongShortRatioService extends DatasetBuilder implements ILongShortRatioService {constructor() {super("./output/long_short_ratio.csv",30);}/*** Retrieves the next dataset items based on the given starting point.* @param start_at* @returns Promise<ILongShortRatioRecord[]>*/protected async get_next_ds_items(start_at: number): Promise<ILongShortRatioRecord[]> {// Retrieve the records from Binance's APIconst records: IRawLongShortRatioRecord[] = await this._binance.get_long_short_ratio_history(start_at);// Finally, format the items and return themreturn records.map((r) => { return <ILongShortRatioRecord>{timestamp: r.timestamp,long_account: this.format_number(r.longAccount, 4),short_account: this.format_number(r.shortAccount, 4),long_short_ratio: this.format_number(r.longShortRatio, 4)} });}}</"file: src\dataset-builder\long-short-ratio.service.ts">

<"file: src\dataset-builder\open-interest.service.ts">import { IRawOpenInterestRecord } from "../binance";import { DatasetBuilder } from "./dataset-builder";import { IOpenInterestRecord, IOpenInterestService } from "./interfaces";export class OpenInterestService extends DatasetBuilder implements IOpenInterestService {constructor() {super("./output/open_interest.csv",30);}/*** Retrieves the next dataset items based on the given starting point.* @param start_at* @returns Promise<IOpenInterestRecord[]>*/protected async get_next_ds_items(start_at: number): Promise<IOpenInterestRecord[]> {// Retrieve the records from Binance's APIconst records: IRawOpenInterestRecord[] = await this._binance.get_open_interest_history(start_at);// Finally, format the items and return themreturn records.map((r) => { return <IOpenInterestRecord>{timestamp: r.timestamp,sum_open_interest: this.format_number(r.sumOpenInterest, 8),sum_open_interest_value: this.format_number(r.sumOpenInterestValue, 8)} });}}</"file: src\dataset-builder\open-interest.service.ts">

<"file: src\dataset-builder\funding-rate.service.ts">import { IRawFundingRateRecord } from "../binance";import { DatasetBuilder } from "./dataset-builder";import { IFundingRateRecord, IFundingRateService } from "./interfaces";export class FundingRateService extends DatasetBuilder implements IFundingRateService {/*** Genesis Timestamp* The time at which Binance Futures first launched and the beginning* of the funding rate history.*/private readonly genesis_timestamp: number = 1568102400000;constructor() {super("./output/funding_rate.csv");}/*** Retrieves the next dataset items based on the given starting point.* @param start_at* @returns Promise<IFundingRateRecord[]>*/protected async get_next_ds_items(start_at: number): Promise<IFundingRateRecord[]> {// Retrieve the records from Binance's APIconst records: IRawFundingRateRecord[] = await this._binance.get_funding_rate_history(start_at);// Finally, format the items and return themreturn records.map((r) => { return <IFundingRateRecord>{timestamp: r.fundingTime,funding_rate: this.format_number(r.fundingRate, 8)} });}/*** This function is invoked when a dataset has not been initialized and* returns the genesis timestamp which was set when Binance Futures stated* operating.* @returns number*/protected calculate_genesis_timestamp(): number { return this.genesis_timestamp }}</"file: src\dataset-builder\funding-rate.service.ts">

<"file: src\dataset-builder\index.ts">import { FundingRateService } from "./funding-rate.service";import { OpenInterestService } from "./open-interest.service";import { LongShortRatioService } from "./long-short-ratio.service";import { TakerBuySellVolumeService } from "./taker-buy-sell-volume.service";// Dataset Buildersconst DS_BUILDERS = [new FundingRateService(),new OpenInterestService(),new LongShortRatioService(),new TakerBuySellVolumeService(),];// Sync Processexport async function sync_datasets(): Promise<void> {for (let ds_builder of DS_BUILDERS) { await ds_builder.sync() }}</"file: src\dataset-builder\index.ts">

<"file: src\dataset-builder\interfaces.ts">/********* Core *********//*** Dataset Builder Class* This class performs the core dataset builder actions and should be* extended by the services.*/export interface IDatasetBuilder {sync(): Promise<void>}// Dataset Itemexport type IDatasetItem = IFundingRateRecord|IOpenInterestRecord|ILongShortRatioRecord|ITakerBuySellVolumeRecord;/*** Dataset Item Skeleton* All datasets built by the script must have the timestamp property (in ms)* so they can be initialized and then synced throught time.*/export interface IDatasetItemSkeleton {timestamp: number}/***************** Funding Rate *****************/// Serviceexport interface IFundingRateService extends IDatasetBuilder { }// Recordexport interface IFundingRateRecord extends IDatasetItemSkeleton {funding_rate: number}/****************** Open Interest ******************/// Serviceexport interface IOpenInterestService extends IDatasetBuilder { }// Recordexport interface IOpenInterestRecord extends IDatasetItemSkeleton {// Total open interest (BTC)sum_open_interest: number,// Total open interest value (USDT)sum_open_interest_value: number}/********************* Long/Short Ratio *********************/// Serviceexport interface ILongShortRatioService extends IDatasetBuilder { }// Recordexport interface ILongShortRatioRecord extends IDatasetItemSkeleton {// Long account num ratio of all traderslong_account: number,// Short account num ratio of all tradersshort_account: number,// Long/Short account num ratio of all traderslong_short_ratio: number}/************************** Taker Buy/Sell Volume **************************/// Serviceexport interface ITakerBuySellVolumeService extends IDatasetBuilder { }// Recordexport interface ITakerBuySellVolumeRecord extends IDatasetItemSkeleton {// Total BTC volume bought by Takersbuy_vol: number,// Total BTC volume sold by Takerssell_vol: number,// The taker buy/sell ratiobuy_sell_ratio: number}</"file: src\dataset-builder\interfaces.ts">

<"file: src\binance\interfaces.ts">/*** Service* This service is responsible for interacting with Binance's Futures API.*/export interface IBinanceService {get_funding_rate_history(start_time: number): Promise<IRawFundingRateRecord[]>,get_open_interest_history(start_time: number): Promise<IRawOpenInterestRecord[]>,get_long_short_ratio_history(start_time: number): Promise<IRawLongShortRatioRecord[]>,get_taker_buy_sell_volume_history(start_time: number): Promise<IRawTakerBuySellVolumeRecord[]>,}/*** Query Date Range* When interacting with historical data through the Binance API, it is important* to provide a full date range as it behaves unexpectedly otherwise.*/export interface IQueryDateRange { start: number, end: number }/*** Raw Funding Rate Record* https://www.binance.com/en/blog/futures/what-is-futures-funding-rate-and-why-it-matters-421499824684903247*/export interface IRawFundingRateRecord {// The request's symbol. Will always be: "BTCUSDT"symbol: string,// The time at which the rate snapshot was takenfundingTime: number,// The funding rate value (String Format)fundingRate: string}/*** Raw Open Interest Record* https://www.binance.com/en/blog/futures/what-information-does-open-interest-convey-421499824684900398*/export interface IRawOpenInterestRecord {// The request's symbol. Will always be: "BTCUSDT"symbol: string,// The time at which the open interest snapshot was takentimestamp: number,// Total open interest (BTC)sumOpenInterest: string,// Total open interest value (USDT)sumOpenInterestValue: string}/*** Raw Long/Short Ratio Record* https://www.binance.com/en/blog/futures/what-is-longshort-ratio-and-what-does-it-convey-in-cryptocurrency-futures-6728490800036398885*/export interface IRawLongShortRatioRecord {// The request's symbol. Will always be: "BTCUSDT"symbol: string,// The time at which the long/short ratio snapshot was takentimestamp: number,// Long account num ratio of all traderslongAccount: string,// Short account num ratio of all tradersshortAccount: string,// Long/Short account num ratio of all traderslongShortRatio: string}/*** Raw Taker Buy/Sell Volume Record* https://www.binance.com/en/feed/post/164092*/export interface IRawTakerBuySellVolumeRecord {// The request's symbol. Will always be: "BTCUSDT"symbol: string,// The time at which the long/short ratio snapshot was takentimestamp: number,// Total BTC volume bought by TakersbuyVol: string,// Total BTC volume sold by TakerssellVol: string,// The taker buy/sell ratiobuySellRatio: string}</"file: src\binance\interfaces.ts">

<"file: src\binance\request-throttle.ts">/*** Request Throttle Decorator* Binance has strict request restrictions when interacting with their* public endpoints. The purpose of this decorator is to avoid getting* blacklisted by their middlewares.* @param seconds*/export const request_throttle = (seconds: number = 2) => {return (target: Object, property_key: string, descriptor: TypedPropertyDescriptor<(... params: any[])=> Promise<any>>) => {let original_func = descriptor.value!;descriptor.value = async function (...args) {await async_delay(seconds);let result = await original_func.apply(this, args);await async_delay(seconds);return result;}}}async function async_delay(seconds: number): Promise<void> {return new Promise((resolve, reject) => { setTimeout(() => { resolve() }, seconds * 1000) });}</"file: src\binance\request-throttle.ts">

<"file: src\dataset-builder\dataset-builder.ts">import * as fs from "fs";import * as path_helper from "path";import { BigNumber } from "bignumber.js";import moment from "moment";import { BinanceService, IBinanceService } from "../binance";import { IDatasetBuilder, IDatasetItem } from "./interfaces";export class DatasetBuilder implements IDatasetBuilder {// The path in which the dataset file is storedprivate dataset_path: string;// The maximum number of lookback days an endpoint can be queriedprivate max_historic_lookback_days: number;// The Binance Service Instance to be accessed by the childrenprotected _binance: IBinanceService;constructor(dataset_path: string,max_historic_lookback_days: number = 30)  {// Initialize the Dataset's Path & Filethis.dataset_path = dataset_path;this.initialize_dataset_file();// Initialize the maximum historic lookbackthis.max_historic_lookback_days = max_historic_lookback_days;// Initialize the Binance Instancethis._binance = new BinanceService();}/*** Initializes or syncs a dataset.* @returns Promise<void>*/public async sync(): Promise<void> {// Print process msgconsole.log(`\n${this.constructor.name} Syncing...\n`);// Load the dataset filelet { latest_timestamp, raw_dataset } = this.load_dataset_file();// Sync the datasetlet new_records_found: boolean = true;while(new_records_found) {// Retrieve the next seriesconst new_items: IDatasetItem[] = await this.get_next_ds_items(latest_timestamp);/*** Only proceed if new items were found. Note that Binance's API seems to* have a glitch on some endpoints and sometimes returns records that have* already been included in the dataset. In order to prevent an infinite* loop, it is important to require at least 2 records.*/if (new_items.length > 1) {// Set the timestamp that will be used on the next querylatest_timestamp = new_items.at(-1)!.timestamp;// If the file is currently empty, add the headingif (!raw_dataset.length) raw_dataset = `${Object.keys(new_items[0]).join(",")}`;// Add the new items to the raw dataset as long as they haven't been already addedraw_dataset += new_items.reduce((accum: string,current_value: IDatasetItem) => {if (raw_dataset.includes(String(current_value.timestamp))) {return accum;} else {return accum + `\n${Object.values(current_value).join(",")}`;}},"");// Update the dataset filethis.update_dataset_file(raw_dataset);}// Otherwise, stop the iterationelse { new_records_found = false }}}/*** Retrieves the next dataset items based on the given starting point.* @OVERRIDE* @param start_at* @returns Promise<IDatasetItem[]>*/protected get_next_ds_items(start_at: number): Promise<IDatasetItem[]> {throw new Error(`${this.constructor.name}.get_next_records has not been implemented.`);}/*** This function is invoked when a dataset has not been initialized.* It calculates the genesis timestamp based on max_historic_lookback_days.* @OVERRIDE If the lookback data uses a different logic (F.e: Funding Rate)* @returns number*/protected calculate_genesis_timestamp(): number {return moment().subtract(this.max_historic_lookback_days, "days").valueOf();}/************************ File System Helpers ************************//*** Initializes the dataset file in case it hadn't been.*/private initialize_dataset_file(): void {// Only proceed if the dataset file does not existif (!this.path_exists(this.dataset_path)) {// Check if the directory needs to be createdconst dir_name: string = path_helper.dirname(this.dataset_path);if (!this.path_exists(dir_name)) fs.mkdirSync(dir_name);// Create the csv filethis.update_dataset_file("");}}/*** Updates the dataset file with the latest state.* @param new_data_state*/private update_dataset_file(new_data_state: string): void {fs.writeFileSync(this.dataset_path, new_data_state, "utf-8");}/*** Verifies if a given directory or file exists.* @returns boolean*/private path_exists(file_or_dir_path: string): boolean {try {fs.accessSync(file_or_dir_path);return true;} catch (e) { return false }}/*** Loads the dataset file and returns it in string format. It also* derives the latest record's timestamp so the syncing can be resumed.* @returns { latest_timestamp: number, raw_dataset: string }*/private load_dataset_file(): { latest_timestamp: number, raw_dataset: string } {// Load the raw dataconst raw_dataset: string = fs.readFileSync(this.dataset_path).toString();// If the file contains data, extract the latest timestampif (raw_dataset.length) {return {latest_timestamp: Number(raw_dataset.split("\n").at(-1)!.split(",")[0]),raw_dataset: raw_dataset}}// Otherwise, return the defaultselse { return { latest_timestamp: this.calculate_genesis_timestamp(), raw_dataset: "" } }}/***************** Misc Helpers *****************//*** Formats a number into the proper format. The value returned from* this function is the one that will be stored in the ds.* @param value* @param decimal_places* @param round_up* @returns number*/protected format_number(value: number|string|BigNumber,decimal_places: number = 2,round_up: boolean = true): number {// Initialize the value's instanceconst bn: BigNumber = BigNumber.isBigNumber(value) ? value: new BigNumber(value);// Finally, round and format the valuereturn bn.decimalPlaces(decimal_places,round_up ? BigNumber.ROUND_UP: BigNumber.ROUND_DOWN).toNumber();}}</"file: src\dataset-builder\dataset-builder.ts">

<"file: src\binance\binance.service.ts">import moment from "moment";import {ExternalRequestService,IExternalRequestOptions,IExternalRequestResponse,IExternalRequestService} from "../external-request";import { request_throttle } from "./request-throttle";import {IBinanceService,IQueryDateRange,IRawFundingRateRecord,IRawLongShortRatioRecord,IRawOpenInterestRecord,IRawTakerBuySellVolumeRecord} from "./interfaces";export class BinanceService implements IBinanceService {// Binance's Request Options Skeletonprivate readonly request_options: IExternalRequestOptions = {host: "fapi.binance.com",path: "",method: "GET",headers: { "Content-Type": "application/json" }}// External Request Serviceprivate _external_request: IExternalRequestService;constructor() {// Initialize the external request instancethis._external_request = new ExternalRequestService();// ...}/*** Retrieves the funding rate history based on given starting point.* @param start_time* @returns Promise<IRawFundingRateRecord[]>*/@request_throttle()public async get_funding_rate_history(start_time: number): Promise<IRawFundingRateRecord[]> {// Send the requestconst { start, end } = this.calculate_query_date_range(start_time, 200);const response: IExternalRequestResponse = await this._external_request.request({...this.request_options,path: `/fapi/v1/fundingRate?symbol=BTCUSDT&limit=1000&startTime=${start}&endTime=${end}`});// Validate the responsethis.validate_request_response(response);// Return the seriesreturn response.data;}/*** Retrieves the open interest history based on given starting point.* @param start_time* @returns Promise<IRawOpenInterestRecord[]>*/@request_throttle()public async get_open_interest_history(start_time: number): Promise<IRawOpenInterestRecord[]> {// Send the requestconst { start, end } = this.calculate_query_date_range(start_time);const response: IExternalRequestResponse = await this._external_request.request({...this.request_options,path: `/futures/data/openInterestHist?symbol=BTCUSDT&period=5m&limit=500&startTime=${start}&endTime=${end}`});// Validate the responsethis.validate_request_response(response);// Return the seriesreturn response.data;}/*** Retrieves the long/short ratio history based on given starting point.* @param start_time* @returns Promise<IRawLongShortRatioRecord[]>*/@request_throttle()public async get_long_short_ratio_history(start_time: number): Promise<IRawLongShortRatioRecord[]> {// Send the requestconst { start, end } = this.calculate_query_date_range(start_time);const response: IExternalRequestResponse = await this._external_request.request({...this.request_options,path: `/futures/data/globalLongShortAccountRatio?symbol=BTCUSDT&period=5m&limit=500&startTime=${start}&endTime=${end}`});// Validate the responsethis.validate_request_response(response);// Return the seriesreturn response.data;}/*** Retrieves the taker buy/sell volume history based on given starting point.* @param start_time* @returns Promise<IRawTakerBuySellVolumeRecord[]>*/@request_throttle()public async get_taker_buy_sell_volume_history(start_time: number): Promise<IRawTakerBuySellVolumeRecord[]> {// Send the requestconst { start, end } = this.calculate_query_date_range(start_time);const response: IExternalRequestResponse = await this._external_request.request({...this.request_options,path: `/futures/data/takerlongshortRatio?symbol=BTCUSDT&period=5m&limit=500&startTime=${start}&endTime=${end}`});// Validate the responsethis.validate_request_response(response);// Return the seriesreturn response.data;}/***************** Misc Helpers *****************//*** Given an HTTP Response object, it will ensure the request was* processed correctly and has the correct status code.* @param response* @param validate_data*/private validate_request_response(response: IExternalRequestResponse, validate_data: boolean = true): void {// Ensure it is a valid objectif (!response || typeof response != "object") {console.log(response);throw new Error("Binance's API returned an invalid response object.");}// Ensure the status code is validif (response.status_code != 200) {throw new Error(`Binance's API returned an invalid HTTP response code.Expected: 200, Received: ${response.status_code}`);}// Validate the response's dataif (validate_data && !Array.isArray(response.data)) {console.log(response.data);throw new Error(`Binance's API returned an invalid series of records. Received: ${typeof response.data}`);}}/*** Calculates the query's date range based on the starting time.* Keep in mind it will add 1 second to the starting time in order* to prevent duplicate records.* @param start_time* @param query_days_length* @returns IQueryDateRange*/private calculate_query_date_range(start_time: number, query_days_length: number = 1): IQueryDateRange {return {start: start_time + 1000, // Add an extra 1000 millisecondsend: moment(start_time).add(query_days_length, "days").valueOf()}}}</"file: src\binance\binance.service.ts">

<"file: src\binance\index.ts">export *  from "./binance.service";export * from "./interfaces";</"file: src\binance\index.ts">

<"file: package.json">{"name": "binance_futures_dataset_builder","version": "1.0.0","description": "The dataset builder script extracts the most relevant market data straight from Binance's API and builds and stores a series of datasets that can be used in data science and machine learning projects.","main": "./dist/index.js","scripts": {"start": "clear && if [ -d './dist' ]; then rm -r ./dist; fi && npx tsc && node ./dist/index.js","test": "echo \"Error: no test specified\" && exit 1"},"repository": {"type": "git","url": "git+ssh://git@github.com/jesusgraterol/binance_futures_dataset_builder.git"},"keywords": ["Bitcoin","Blockchain","Dataset","Trading","Machine","Learning","Data","Science","Cryptocurrency","Binance","Binance Futures","Bitcoin Futures"],"author": "Jesus Graterol","license": "ISC","bugs": {"url": "https://github.com/jesusgraterol/binance_futures_dataset_builder/issues"},"homepage": "https://github.com/jesusgraterol/binance_futures_dataset_builder#readme","devDependencies": {"@types/node": "^20.5.1","typescript": "^5.1.6"},"dependencies": {"bignumber.js": "^9.1.1","moment": "^2.29.4"}}</"file: package.json">

<"file: error.txt">Error minifying .gitignore: Unsupported file format</"file: error.txt">

